<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2020.2.23 模拟赛 游记&amp;题解 | 向北方的个人博客</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zmxqs.github.io/favicon.ico?v=1627466266765">
<link rel="stylesheet" href="https://zmxqs.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="Case 1.游记
一开始老师说是1:301:301:30发题，结果提前1h1h1h发了，十分惊讶……
看了第一题，写了个5min5min5min结束。
第二题感觉是贪心，但是又整不出来？写了20min20min20min毫无思路，到了1:..." />
    <meta name="keywords" content="模拟赛游记,模拟赛题解" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zmxqs.github.io">
        <img src="https://zmxqs.github.io/images/avatar.png?v=1627466266765" class="site-logo">
        <h1 class="site-title">向北方的个人博客</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      向北方的个人博客
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zmxqs.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">2020.2.23 模拟赛 游记&amp;题解</h2>
            <div class="post-date">2020-02-26</div>
            
            <div class="post-content" v-pre>
              <h2 id="case-1游记">Case 1.游记</h2>
<p>一开始老师说是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>:</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">1:30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>发题，结果提前<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>h</mi></mrow><annotation encoding="application/x-tex">1h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">h</span></span></span></span>发了，十分惊讶……</p>
<p>看了第一题，写了个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">5min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>结束。</p>
<p>第二题感觉是贪心，但是又整不出来？写了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">20min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>毫无思路，到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>:</mo><mn>00</mn></mrow><annotation encoding="application/x-tex">1:00</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span></span></span></span>去睡午觉了。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>:</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">2:30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span>回来之后，思路理顺了，一会儿就写完了。</p>
<p>第三题一开始想用 <strong>和yy一样的算法（后来看他程序发现差不多）</strong> ，但是觉得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">n \leq 5 \times 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 不是很友好 <s>万一老师机子是老年机呢</s> 。而且，对于老师的机子我毫无信任，感觉<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>卡不过去。</p>
<p>于是我简单的打了几个表，发现了一些规律，然后就完事了。</p>
<p>第四题后来发现你谷有原题！（<strong>大惊</strong>）不过当时写的大模拟太丑了。</p>
<p>第五题第一感宽搜。发现：<strong>用优先队列宽搜还是第一次。</strong></p>
<p>第六题吗，二分答案。</p>
<p><s>本来想提前1.5h交卷</s> 最后还是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">5min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>前交了。</p>
<p><strong>后来觉得开O2万一爆0就没意思了，于是把O2注释掉了。</strong></p>
<h2 id="case-2题解">Case 2.题解</h2>
<h3 id="t1num">T1.num</h3>
<p>简要题意：水题。</p>
<p>直接模拟，轻松<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>.</p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int main(){
	freopen(&quot;num.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;num.out&quot;,&quot;w&quot;,stdout);
	int k=read(); bool f=0;
	for(int i=10000;i&lt;=30000;i++) {
		int x=i/100;
		int y=(i/10)%1000;
		int z=i%1000;
		if(x%k || y%k || z%k) continue;
		if(!f) f=1;
		printf(&quot;%d\n&quot;,i);
	}
	if(!f) printf(&quot;No\n&quot;);
	return 0;
}
</code></pre>
<hr>
<h3 id="t2evac">T2.evac</h3>
<p>考虑贪心。<strong>对于每行最右边的和每列最上面的，优先从该行（列）通过，并标记。对于其它的，则优先选行，再选列。（其实无所谓）</strong></p>
<p>枚举去掉哪一个。最后把所有的合起来检验一遍，就可以了。</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>×</mo><mi>r</mi><mo>×</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n \times r \times c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>.（十分优秀）</p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=1e2+1;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int r,c,n;
int x[N],y[N];
int h[N][N],ans[N],tot=0;
bool safe=true,go=false;

int kkk[N][N]; bool e[N];
bool hang[N],lie[N];

inline bool check(int xxx){
	memset(e,0,sizeof(e));
	memset(hang,0,sizeof(hang));
	memset(lie,0,sizeof(lie));
	for(int i=1;i&lt;=r;i++)
		for(int j=1;j&lt;=c;j++) kkk[i][j]=h[i][j];
	for(int i=1;i&lt;=r;i++) {
		for(int j=c;j&gt;=1;j--)
			if(kkk[i][j]) {
				e[kkk[i][j]]=1;
				hang[i]=1;
				break;
			}
	}
	for(int j=1;j&lt;=c;j++) {
		for(int i=1;i&lt;=r;i++) {
			if(!kkk[i][j]) continue;
			if(e[kkk[i][j]]) {lie[j]=1;break;}
			if(!e[kkk[i][j]]) {
				lie[j]=1; e[kkk[i][j]]=1;
				break;
			}
		} 
	}
	for(int i=1;i&lt;=n;i++) {
		if(i==xxx) continue;
		if(!e[i]) {
			int X=x[i],Y=y[i];
			if(!hang[X]) hang[X]=1;
			else if(!lie[Y]) lie[Y]=1;
			else return false;
		} 
	} return true;
}

int main(){
	freopen(&quot;evac.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;evac.out&quot;,&quot;w&quot;,stdout);
	r=read(),c=read(),n=read();
	for(int i=1;i&lt;=n;i++) {
		x[i]=read(),y[i]=read();
		h[x[i]][y[i]]=i;
	}
	for(int i=1;i&lt;=n;i++) {
		h[x[i]][y[i]]=0;
		bool f=check(i);
		if(f==true) {
			go=true;
			ans[++tot]=i;
		} else safe=false;
		h[x[i]][y[i]]=i;
 	}
 	if(safe==true) safe=check(0);
 	if(safe==true) printf(&quot;0\n&quot;);
 	else if(go==false) printf(&quot;-1\n&quot;);
 	else for(int i=1;i&lt;=tot;i++) printf(&quot;%d\n&quot;,ans[i]);
	return 0;
}

</code></pre>
<h3 id="t3fact">T3.fact.</h3>
<p>第一眼看上去，这题直接暴力完事。就是暴力阶乘，然后对于末尾<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>直接去掉，每次只留个位，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>轻松通过。</p>
<p>但是，<s>机房的惨案提前了我，老师的机子是老年机</s> 因此我要考虑更优的算法。</p>
<p>一番打表之后……</p>
<p>发现：答案只会是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2,4,6,8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span>中的一个。并以周期出现。</p>
<p>然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 依次除以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn></mrow><annotation encoding="application/x-tex">5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>，个位累乘，并每次在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(2,4,6,8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span>中选择即可。</p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int n,ans=1;
int a[4]={6,8,4,2};

int main(){
	freopen(&quot;fact.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;fact.out&quot;,&quot;w&quot;,stdout);
	n=read();
	while(n&gt;0) {
		for(int i=1;i&lt;=n%10;i++)
			if(i!=5) ans=(ans*i)%10;
		n/=5;
		ans=(ans*a[n%4])%10;
//		printf(&quot;%d %d\n&quot;,n,ans);
	} printf(&quot;%d\n&quot;,ans);
	return 0;
}

</code></pre>
<h3 id="t4heart">T4.heart</h3>
<p>这题一看非常熟悉。（你谷有原题）</p>
<p>暴力模拟了一下，发现直接过了。 <strong>注意细节</strong> 。</p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int card[5];
bool m[5][17];

int point[17]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,100,0};

inline void print(int x) {
	if(x&gt;0) putchar('+');
	printf(&quot;%d &quot;,x);
}

int main(){
	freopen(&quot;heart.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;heart.out&quot;,&quot;w&quot;,stdout);
	while(1) {
		memset(m,0,sizeof(m));
		int l=0;
		for(int i=1;i&lt;=4;i++) {
			card[i]=read(); l+=card[i];
			for(int j=1;j&lt;=card[i];j++) {
				char c; cin&gt;&gt;c;
				int p=read();
				switch(c) {
					case 'H': {m[i][p]=true;break;}
					case 'S': {m[i][14]=true;break;}
					case 'D': {m[i][15]=true;break;}
					case 'C': {m[i][16]=true;break;}
				}
			}
		}
		if(!l) break;
	/*	for(int i=1;i&lt;=4;i++) {
			for(int j=1;j&lt;=16;j++) printf(&quot;%d &quot;,m[i][j]);
			putchar('\n');
		}*/
		for(int i=1;i&lt;=4;i++) {
			int t=0,all=true;
			for(int j=1;j&lt;=13;j++)
				if(!m[i][j]) {all=false;break;}
			if(all==true) {
				t=200;
				if(m[i][14] &amp;&amp; m[i][15]) t=500;
				else t=t+m[i][14]*point[14]+m[i][15]*point[15];
				if(m[i][16]) t*=2;
				print(t);
			} else {
				bool f=true;
				for(int j=1;j&lt;=15;j++)
					if(m[i][j]) {f=false;break;}
				if(f==true) {
					if(m[i][16]) t=50;
					print(t);
				} else {
					for(int j=1;j&lt;=15;j++) t=t+m[i][j]*point[j];
					if(m[i][16]) t*=2;
					print(t);
				}
			}
		}
		putchar('\n');
	}
	return 0;
}

</code></pre>
<h3 id="t5color">T5.color</h3>
<p>本场考试我认为最难的一道题目。</p>
<p>一开始我考虑朴素宽搜，但想到一个问题：不一定变化少的一定在变化多的前面。 <strong>这是因为按照四方向走有的不变，有的变，而这些都被列为是同答案的，就不对了。</strong></p>
<p>后来冥思苦想了一阵，何不用优先队列呢？ <strong>其实原来的宽搜不用优先队列是因为能保证数据的有序，这里无法保证这一点了，只能这样做。</strong></p>
<p>分析一下时间复杂度：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mo>(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo>)</mo><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O((n \times m) \log (n \times m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.</p>
<p>这个复杂度我并不是很满意，毕竟如果跑满数据（老年机）的情况下，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">n \times m =10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，总时间约为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2 \times 10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>众所周知老年机一秒只能跑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">10^7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span>.但是想了想，没有比这更优的算法了。优先队列真是好东西（要是不带<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>就完美了）</strong></p>
<p>后来就这样一交，没想到竟然<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span>了。老师的电脑看来比机房要好很多。</p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=2001;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int n,m,s,e;
int ans[N][N];
int a[N][N];

struct node{
	int x,y,step;
	bool operator &lt; (const node &amp;a) const {
		return step&gt;a.step;
	}
};
priority_queue&lt;node&gt;q;

const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};

inline node pr(int x,int y,int step) {
	node p; p.x=x; p.y=y; p.step=step;
	return p;
}

int main(){
	freopen(&quot;color.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;color.out&quot;,&quot;w&quot;,stdout);
	n=read(),m=read(),s=read(),e=read();
	for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)	a[i][j]=read();
	q.push(pr(s,e,0));
	for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) ans[i][j]=INT_MAX;
	ans[s][e]=0;
	while(!q.empty()) {
		node t=q.top();
		int x=t.x,y=t.y,step=t.step;
//		printf(&quot;%d %d %d\n&quot;,x,y,step);
		q.pop();
		for(int i=0;i&lt;4;i++) {
			int nx=x+dx[i],ny=y+dy[i];
			if(nx&lt;1 || nx&gt;n || ny&lt;1 || ny&gt;m) continue;
			int l=(a[nx][ny]==a[x][y])?0:1;
			if(ans[nx][ny]&gt;step+l) {
				ans[nx][ny]=step+l;
				q.push(pr(nx,ny,step+l));
			}
		}
	}
	for(int i=1;i&lt;=n;i++) {
		for(int j=1;j&lt;=m;j++) printf(&quot;%d &quot;,ans[i][j]);
		putchar('\n');
	}
	return 0;
}

</code></pre>
<h3 id="t6harmony">T6.harmony</h3>
<p>一开始以为不用连续取，感觉压轴题来了；后来仔细一读——<strong>水题，大大的水题！</strong></p>
<p>首先我们二分这个最大值，然后连续地划分区间，直到该区间的极差超过当前值，那么就另立门户。</p>
<p><strong>里面有一些细节一开始没注意，后来都改过来了。</strong></p>
<pre><code class="language-cpp">// #pragma GCC optimize(2)
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+1;

inline int read(){char ch=getchar();int f=1;while(ch&lt;'0' || ch&gt;'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0;while(ch&gt;='0' &amp;&amp; ch&lt;='9') x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-'0',ch=getchar();return x*f;}

int n,k;
int a[N];

inline bool check(int x) {
	int s=1,maxi=1,mini=1e9;
	for(int i=1;i&lt;=n;i++) {
		int u=max(maxi,a[i]),v=min(mini,a[i]);
		if(u-v&gt;x) {
			s++; if(s&gt;k) return 0;
			maxi=mini=a[i];
		}
		else maxi=u,mini=v;
	} return 1;
}

int main(){
	freopen(&quot;harmony.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;harmony.out&quot;,&quot;w&quot;,stdout);
	n=read(),k=read();
	int maxi=1,mini=1e9;
	for(int i=1;i&lt;=n;i++) {
		a[i]=read();
		maxi=max(maxi,a[i]);
		mini=min(mini,a[i]);
	}
	int l=1,r=maxi-mini,ans=INT_MAX;
	while(l&lt;=r) {
		int mid=(l+r)&gt;&gt;1;
		if(check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
	} printf(&quot;%d\n&quot;,ans);
	return 0;
}

</code></pre>
<h2 id="后记">后记</h2>
<p>总之，这场比赛愉快地<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">AK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>了，希望大家也能有所收获吧。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zmxqs.github.io/tag/DuQsxvVl1/" class="tag">
                    模拟赛游记
                  </a>
                
                  <a href="https://zmxqs.github.io/tag/4g2QMjTjA/" class="tag">
                    模拟赛题解
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://zmxqs.github.io/post/mo-ni-sai-field-jie-ti-bao-gao/">
                  <h3 class="post-title">
                    2020.2.25 模拟赛 field 解题报告
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'zmxqs',
        clientSecret: 'zmxqs',
        repo: 'zmxqs.github.io',
        owner: 'zmxqs',
        admin: ['zmxqs'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
